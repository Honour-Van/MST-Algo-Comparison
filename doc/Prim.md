## Prim

prim算法的过程中每次加入一个点，一共会加入$N$轮

每轮中需要找到一个距离已有点最小的点，使用遍历的方式查找，时间复杂度为 $O(N)$

同时每个点会更新它的邻边

每条边会被两个点更新两次，因此总的所有点更新边的时间复杂度为 $O(M)$

因此Prim算法的时间复杂度为 $O(N^2+M)$

空间上需要存储整个图

空间复杂度为 $O(N+M)$



## Prim 堆优化

Prim堆优化算法是在Prim的基础上进行了改进

我们可以看到在Prim算法的时间复杂度上，$O(N^2)$ 占据了较大的比例，而它的来源是每一次的查找最大值

因此Prim堆优化就是使用堆来找到最大值

每次用边更新节点时，会将如果更新了结点的值，则会将更新的结点的距离加入堆中，因此堆的大小与边数有关，为 $O(M)$。

每次更新的时间是 $O(\log M)$的，每条边都可能会进行一次，因此时间复杂度为 $O(M\log M)$

而在每次通过堆获得最小值时，时间复杂度为 $O(\log M)$，共进行N轮

因此总的时间复杂度为 $O(N\log M + M\log M)$

因为堆的空间复杂度为 $O(M)$，因此空间复杂度仍为 $O(N+M)$



## Kruskal

在Kruskal算法中，有对边权进行排序的工作，使用快速排序、归并排序等算法进行排序，时间复杂度为$O(M\log M)$

在之后的并查集中，最坏进行M轮判定，每次判定两个结点是否连通需要$O(\alpha(N))$

总的时间复杂度为 $O(M\log M+M\alpha(M,N))$

并查集空间复杂度为 $O(N)$ 空间复杂度为 $O(N+M)$



在最小生成树的问题中，通常我们有$N<M<N^2$ 因此带入关系，我们总结上述算法可以得到下表：

|            | Prim     | Prim堆优化   | Kruskal      |
| ---------- | -------- | ------------ | ------------ |
| 时间复杂度 | $O(N^2)$ | $O(M\log M)$ | $O(M\log M)$ |
| 空间复杂度 | $O(M)$   | $O(M)$       | $O(M)$       |



其中Prim堆优化和Kruskal虽然都是$O(M\log M)$

但是Prim堆优化中只有更新了距离值的边才会加入堆中，因此这个$M$的值是会十分小的，尤其是在等权的情况下。

而Kruskal的$M$则是固定为图中的边数$M$，如果使用快速排序，其复杂度甚至可能在$O(M\log M)$到$O(M^2)$间摆动

